<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tool Ghép Skin — FIXED (log + upload acc/lichsu + MS)</title>
<style>
  body{font-family:Inter,system-ui,Arial;background:#f5f7fb;color:#111;margin:0;padding:12px}
  h2{margin:6px 0 12px}
  .wrap{max-width:1100px;margin:0 auto}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
  .card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(10,10,10,0.06)}
  textarea{width:100%;height:110px;font-family:monospace;border:1px solid #e6e6e6;padding:8px;border-radius:8px;resize:vertical}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{background:#1f8ef1;color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.ghost{background:#eee;color:#111}
  input[type=file]{display:none}
  label.filebtn{background:#0b76d1;color:#fff;padding:8px 10px;border-radius:6px;cursor:pointer}
  input[type=text],select{padding:8px;border-radius:6px;border:1px solid #ddd}
  canvas{width:100%;max-width:807px;border:1px solid #ddd;border-radius:8px;display:block}
  .log{background:#0b1a2b;color:#bfe;text-align:left;padding:8px;border-radius:6px;height:160px;overflow:auto;font-family:monospace;white-space:pre-wrap}
  .thumbs{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .thumb{width:56px;height:56px;border:1px solid #eee;border-radius:6px;display:flex;align-items:center;justify-content:center;background:#fafafa;overflow:hidden}
  .small{font-size:13px;color:#666}
  @media(max-width:900px){ .grid{grid-template-columns:1fr} canvas{max-width:100%} }
</style>
</head>
<body>
<div class="wrap">
  <h2>Tool Ghép Skin — FIXED (log đầy đủ, upload acc/lichsu, nhập MS)</h2>

  <div class="grid">
    <div class="card">
      <div class="small">1) Dán chuỗi thông tin acc (vd: ... SKIN : 307 ... SS : [Tel'Annas ...])</div>
      <textarea id="accText" placeholder="Dán chuỗi thông tin acc ở đây..."></textarea>

      <div style="margin-top:8px" class="row">
        <button id="btnLoad">Load & Ghép</button>
        <button id="btnDownload" class="ghost">Tải ảnh</button>
        <select id="scaleSelect" style="margin-left:auto">
          <option value="1">Canvas scale 1x</option>
          <option value="1.5">Canvas scale 1.5x</option>
          <option value="2">Canvas scale 2x</option>
        </select>
      </div>

      <hr>

      <div class="small">2) Upload ảnh (từ iPhone hoặc PC)</div>
      <div class="row" style="margin-top:6px">
        <label class="filebtn">Upload Ảnh ACC<input id="accFile" type="file" accept="image/*"></label>
        <label class="filebtn">Upload Ảnh Lịch Sử<input id="lichsuFile" type="file" accept="image/*"></label>
        <label class="filebtn">Upload Toado JSON<input id="localToado" type="file" accept=".json"></label>
      </div>

      <div style="margin-top:8px" class="row">
        <label class="small">3) Mã số (MS):</label>
        <input id="msInput" type="text" placeholder="001" style="width:120px">
        <div style="margin-left:auto" class="small">Toado URL:
          <input id="toadoUrl" type="text" value="https://raw.githubusercontent.com/HoshinoKotaSouma/ctvhogo/main/ToadoXyz.json" style="width:320px">
        </div>
      </div>

      <div style="margin-top:8px" class="small">4) FileId (skin → url):</div>
      <div style="margin-top:6px" class="small"><input id="fileIdUrl" type="text" value="https://raw.githubusercontent.com/HoshinoKotaSouma/ctvhogo/main/FileIdtuong.json" style="width:100%"></div>

      <hr>

      <div class="small">Thumbnails (skin trong crop):</div>
      <div id="thumbs" class="thumbs"></div>

      <hr>

      <div class="small">Log (mỗi bước sẽ in ở đây):</div>
      <div id="log" class="log">(log sẽ hiện tại đây)</div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Canvas kết quả</div>
        <div class="small" id="countInfo">Tướng: 0 — Skin: 0 — Ghép: 0</div>
      </div>
      <canvas id="canvas" width="807" height="1280"></canvas>
    </div>
  </div>
</div>

<script>
(async ()=>{

/* ---------------------------
   Helpers & Globals
   --------------------------- */
const $ = id => document.getElementById(id);
const logEl = $('log');
function log(...parts){
  const t = new Date().toLocaleTimeString();
  logEl.textContent += `[${t}] ` + parts.map(p => (typeof p === 'object' ? JSON.stringify(p) : String(p))).join(' ') + '\n';
  logEl.scrollTop = 99999;
}

// Try fetch JSON with fallback adjustments (remove refs/heads, try main path)
async function fetchJsonRobust(url){
  log("-> fetchJsonRobust try", url);
  const candidates = [url];
  try {
    // Normalize github blob -> raw if needed
    if(url.includes('/blob/')) candidates.push(url.replace('https://github.com/', 'https://raw.githubusercontent.com/').replace('/blob/', '/'));
    // If url contains refs/heads, try removing that
    if(url.includes('/refs/heads/')) candidates.push(url.replace('/refs/heads/','/'));
    // If url contains raw.githubusercontent but wrong pattern, try replace pattern to /<branch>/
    const m = url.match(/raw\.githubusercontent\.com\/([^\/]+)\/([^\/]+)\/refs\/heads\/([^\/]+)\/(.+)/);
    if(m) candidates.push(`https://raw.githubusercontent.com/${m[1]}/${m[2]}/${m[3]}/${m[4]}`);
    // also try allorigins fallback
    candidates.push('https://api.allorigins.win/raw?url=' + encodeURIComponent(url));
  } catch(e){ /* ignore */ }

  let lastErr = null;
  for(const c of candidates){
    try{
      log("Try fetch", c);
      const r = await fetch(c);
      if(!r.ok){ lastErr = new Error('HTTP '+r.status+' for '+c); log('fetch failed', r.status, c); continue; }
      const data = await r.json();
      log('Fetch OK', c);
      return data;
    } catch(err){
      lastErr = err;
      log('Fetch error for', c, '-', err.message || err);
      // continue try next candidate
    }
  }
  throw lastErr || new Error('Fetch failed for ' + url);
}

function githubBlobToRaw(u){
  if(!u) return u;
  if(u.includes('raw.githubusercontent.com')) return u;
  if(u.startsWith('https://github.com/')) return u.replace('https://github.com/', 'https://raw.githubusercontent.com/').replace('/blob/', '/');
  return u;
}

function loadImage(url, timeout=12000){
  return new Promise((res, rej)=>{
    if(!url) return rej(new Error('No URL'));
    const img = new Image();
    img.crossOrigin = 'anonymous';
    let done = false;
    const t = setTimeout(()=>{ if(!done){ done=true; rej(new Error('Timeout ' + url)); } }, timeout);
    img.onload = ()=>{ if(done) return; done=true; clearTimeout(t); res(img); };
    img.onerror = ()=>{ if(done) return; done=true; clearTimeout(t); rej(new Error('Load error ' + url)); };
    img.src = url;
  });
}

function readFileAsDataURL(file){
  return new Promise((res, rej)=>{
    const fr = new FileReader();
    fr.onload = e => res(e.target.result);
    fr.onerror = rej;
    fr.readAsDataURL(file);
  });
}

/* ---------------------------
   UI elements
   --------------------------- */
const canvas = $('canvas');
const ctx = canvas.getContext('2d');
const accFileInput = $('accFile');
const lichsuFileInput = $('lichsuFile');
const localToadoInput = $('localToado');
const thumbsEl = $('thumbs');
const countInfo = $('countInfo');

/* ---------------------------
   State
   --------------------------- */
let toadoData = null;
let fileIdMap = {};
let localToadoJson = null; // optional

/* ---------------------------
   Init: load Toado & FileId (robust)
   --------------------------- */
async function init(){
  log('Khởi tạo tool...');
  const toadoUrl = $('toadoUrl').value.trim();
  const fileIdUrl = $('fileIdUrl').value.trim();
  // if user uploaded local toado earlier, we will use that
  if(localToadoJson){
    toadoData = localToadoJson;
    log('Sử dụng Toado JSON từ file local (upload).');
  } else {
    try{
      log('Tải Toado từ', toadoUrl);
      toadoData = await fetchJsonRobust(toadoUrl);
    } catch(err){
      log('❌ Lỗi tải Toado:', err.message || err);
      // keep null, but continue
    }
  }

  try{
    log('Tải FileId từ', fileIdUrl);
    const fileObj = await fetchJsonRobust(fileIdUrl);
    // Build mapping: support array or object
    fileIdMap = {};
    if(Array.isArray(fileObj)){
      for(const it of fileObj){
        // support structures like {skin: name, url:..., raw:...}
        const name = (it.skin || it.name || '').trim();
        let url = it.url || it.raw || it.link || '';
        if(url) url = githubBlobToRaw(url);
        if(name) fileIdMap[name] = url;
      }
    } else if(typeof fileObj === 'object'){
      for(const k of Object.keys(fileObj)){
        let v = fileObj[k];
        if(typeof v === 'string') v = githubBlobToRaw(v);
        fileIdMap[k] = v;
      }
    }
    log('FileId map entries:', Object.keys(fileIdMap).length);
  } catch(err){
    log('⚠️ Lỗi tải FileId:', err.message || err);
  }
}

/* ---------------------------
   Event handlers: file uploads
   --------------------------- */
accFileInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  try{
    const dataUrl = await readFileAsDataURL(f);
    const img = new Image();
    img.onload = ()=>{ log('Ảnh ACC load OK'); accFileInput._img = img; };
    img.onerror = ()=>{ log('❌ Lỗi ảnh ACC'); };
    img.src = dataUrl;
  }catch(err){ log('❌ Read ACC file error', err.message || err); }
});

lichsuFileInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  try{
    const dataUrl = await readFileAsDataURL(f);
    const img = new Image();
    img.onload = ()=>{ log('Ảnh Lịch Sử load OK'); lichsuFileInput._img = img; };
    img.onerror = ()=>{ log('❌ Lỗi ảnh Lịch Sử'); };
    img.src = dataUrl;
  }catch(err){ log('❌ Read lichsu file error', err.message || err); }
});

localToadoInput.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  try{
    const txt = await f.text();
    localToadoJson = JSON.parse(txt);
    toadoData = localToadoJson;
    log('Sử dụng Toado JSON từ file local upload.');
  }catch(err){ log('❌ Lỗi đọc Toado file:', err.message || err); }
});

/* ---------------------------
   Parsing acc text
   --------------------------- */
function parseAcc(text){
  const res = { tuong:0, skinCount:0, cropSkins:[] };
  if(!text) return res;
  const tMatch = text.match(/TƯỚNG\s*:\s*(\d+)/i);
  const sMatch = text.match(/SKIN\s*:\s*(\d+)/i);
  res.tuong = tMatch ? parseInt(tMatch[1]) : 0;
  res.skinCount = sMatch ? parseInt(sMatch[1]) : 0;
  const bracketRe = /\[([^\]]+)\]/g;
  let m;
  const arr = [];
  while((m = bracketRe.exec(text)) !== null){
    const inside = m[1];
    inside.split(',').map(s => s.trim()).filter(Boolean).forEach(s => arr.push(s));
  }
  res.cropSkins = [...new Set(arr)];
  return res;
}

/* ---------------------------
   Draw helpers
   --------------------------- */
function setCanvasSizeForToado(scale = 1){
  if(!toadoData || !toadoData.image) {
    // fallback to default canvas size
    canvas.width = Math.round(807 * scale);
    canvas.height = Math.round(1280 * scale);
    return;
  }
  const ow = toadoData.image.originalWidth || toadoData.image.width || 807;
  const oh = toadoData.image.originalHeight || toadoData.image.height || 1280;
  canvas.width = Math.round(ow * scale);
  canvas.height = Math.round(oh * scale);
}

function getScale(){
  if(!toadoData || !toadoData.image) return { sx: 1, sy: 1 };
  const ow = toadoData.image.originalWidth || canvas.width;
  const oh = toadoData.image.originalHeight || canvas.height;
  return { sx: canvas.width / ow, sy: canvas.height / oh };
}

function drawBaseImage(img){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,canvas.width,canvas.height);
}

function drawTextAt(coord, text, opts = {}){
  if(!coord) return;
  const { sx, sy } = getScale();
  const x = coord.x * sx, y = coord.y * sy;
  const size = opts.size || 36 * ((sx+sy)/2);
  ctx.font = `bold ${Math.round(size)}px sans-serif`;
  ctx.lineWidth = Math.max(2, Math.round(size/12));
  ctx.strokeStyle = opts.stroke || '#000';
  ctx.fillStyle = opts.fill || '#fff';
  ctx.textBaseline = 'alphabetic';
  ctx.strokeText(text, x, y);
  ctx.fillText(text, x, y);
}

function drawImageInRegion(img, region){
  if(!img || !region) return;
  const { sx, sy } = getScale();
  const dx = region.x * sx, dy = region.y * sy, dw = region.w * sx, dh = region.h * sy;
  // preserve aspect: fit cover center
  const imgRatio = img.width / img.height;
  const boxRatio = dw / dh;
  let drawW = dw, drawH = dh, offsetX = 0, offsetY = 0;
  if(imgRatio > boxRatio){
    // img wider → fill height
    drawH = dh; drawW = img.width * (dh / img.height);
    offsetX = (dw - drawW) / 2;
  } else {
    // img taller → fill width
    drawW = dw; drawH = img.height * (dw / img.width);
    offsetY = (dh - drawH) / 2;
  }
  ctx.drawImage(img, dx + offsetX, dy + offsetY, drawW, drawH);
}

/* ---------------------------
   drawSkinsInCrop (kept logic, robust)
   --------------------------- */
async function drawSkinsInCrop(cropRegion, skinNames){
  if(!cropRegion || !Array.isArray(skinNames) || skinNames.length===0) return 0;
  const { sx, sy } = getScale();
  const cx = cropRegion.x * sx, cy = cropRegion.y * sy;
  const cw = cropRegion.w * sx, ch = cropRegion.h * sy;
  const n = skinNames.length;
  const cols = Math.max(1, Math.ceil(Math.sqrt(n * (cw/ch))));
  const rows = Math.max(1, Math.ceil(n / cols));
  const tileW = cw / cols, tileH = ch / rows;

  // load all images with fallback
  const pairs = await Promise.all(skinNames.map(async name=>{
    const url = fileIdMap[name] || fileIdMap[name.trim()] || null;
    if(!url) return { name, img: null, url: null };
    try{
      const loaded = await loadImage(url, 12000);
      return { name, img: loaded, url };
    } catch(e){
      log('⚠️ Skin load failed:', name, e.message || e);
      // try githubBlobToRaw fallback
      try{
        const raw = githubBlobToRaw(url);
        const loaded2 = await loadImage(raw, 12000);
        return { name, img: loaded2, url: raw };
      }catch(e2){
        return { name, img: null, url };
      }
    }
  }));

  let idx = 0;
  for(let r = 0; r < rows; r++){
    for(let c = 0; c < cols; c++){
      if(idx >= pairs.length) break;
      const it = pairs[idx++];
      const dx = cx + c * tileW, dy = cy + r * tileH;
      if(it.img){
        // cover tile with preserving aspect (same method as drawImageInRegion but simpler: fit)
        const scale = Math.max(tileW / it.img.width, tileH / it.img.height);
        const dw = it.img.width * scale, dh = it.img.height * scale;
        const px = dx + (tileW - dw) / 2;
        const py = dy + (tileH - dh) / 2;
        ctx.drawImage(it.img, px, py, dw, dh);
      } else {
        ctx.fillStyle = '#efefef';
        ctx.fillRect(dx, dy, tileW, tileH);
        ctx.fillStyle = '#333';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(it.name || 'no-img', dx + tileW/2, dy + tileH/2);
      }
    }
  }

  return pairs.length;
}

/* ---------------------------
   Main: hook up events
   --------------------------- */
await init();

$('btnLoad').addEventListener('click', async ()=>{
  log('=== Bắt đầu xử lý acc ===');
  try{
    // refresh toado if user changed URL or uploaded local file
    if(localToadoJson){
      toadoData = localToadoJson;
      log('Sử dụng Toado từ file upload (local).');
    } else {
      const url = $('toadoUrl').value.trim();
      if(!toadoData || toadoData._source !== url){ // try re-fetch if changed
        try{ toadoData = await fetchJsonRobust(url); toadoData._source = url; log('Toado loaded from', url); }
        catch(e){ log('❌ Không tải được Toado:', e.message || e); /* continue with previous if exists */ }
      }
    }

    if(!toadoData){ alert('Không có toadoData. Bật log để xem lỗi tải JSON.'); return; }

    const fileIdUrl = $('fileIdUrl').value.trim();
    if(Object.keys(fileIdMap).length === 0 && fileIdUrl){
      try{ const fi = await fetchJsonRobust(fileIdUrl); 
        // rebuild fileIdMap
        fileIdMap = {}; if(Array.isArray(fi)){ for(const it of fi){ const name = (it.skin||it.name||'').trim(); let url = it.url||it.raw||it.link||''; if(url) url = githubBlobToRaw(url); if(name) fileIdMap[name] = url; } } else if(typeof fi === 'object'){ for(const k of Object.keys(fi)){ let v = fi[k]; if(typeof v === 'string') v = githubBlobToRaw(v); fileIdMap[k] = v; } }
        log('FileId reloaded entries:', Object.keys(fileIdMap).length);
      } catch(err){ log('⚠️ Không tải FileId:', err.message || err); }
    }

    const accText = $('accText').value.trim();
    if(!accText){ alert('Dán chuỗi acc vào ô bên trái'); return; }
    const parsed = parseAcc(accText);
    log('Parsed acc:', parsed);

    // scale & canvas sizing
    const scaleChoice = parseFloat($('scaleSelect').value) || 1;
    setCanvasSizeForToado(scaleChoice);

    // load base image
    let baseImg = null;
    try{
      log('Tải ảnh nền từ', toadoData.image && (toadoData.image.url || toadoData.image));
      baseImg = await loadImage(toadoData.image.url, 15000);
    } catch(err){
      log('⚠️ Tải ảnh nền thất bại, thử githubBlobToRaw fallback', err.message || err);
      try{
        const alt = githubBlobToRaw(toadoData.image.url || toadoData.image);
        baseImg = await loadImage(alt, 15000);
        log('Fallback base image OK');
      }catch(err2){
        log('❌ Không thể tải ảnh nền:', err2.message || err2);
        alert('Không thể tải ảnh nền; xem log để biết chi tiết');
        return;
      }
    }
    // draw base
    drawBaseImage(baseImg);

    // draw tướng & skin counts
    if(toadoData.tuong && toadoData.tuong.original){
      drawTextAt(toadoData.tuong.original, parsed.tuong, { fill: '#fff', stroke:'#000', size:36*scaleChoice });
    } else {
      log('⚠️ toadoData.tuong missing');
    }
    if(toadoData.skin && toadoData.skin.original){
      drawTextAt(toadoData.skin.original, parsed.skinCount, { fill: '#fff', stroke:'#000', size:36*scaleChoice });
    } else { log('⚠️ toadoData.skin missing'); }

    // draw acc image if uploaded
    if(accFileInput.files && accFileInput.files[0]){
      const f = accFileInput.files[0];
      try{
        const dataUrl = await readFileAsDataURL(f);
        const img = await new Promise((res, rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=()=>rej('acc img load fail'); i.src=dataUrl; });
        // try find region
        const reg = (toadoData.extra && (toadoData.extra.acc || toadoData.extra.accCrop)) || (toadoData.extraAcc || null);
        if(reg) { drawImageInRegion(img, reg); log('✓ Ảnh ACC chèn vào region'); } 
        else { log('⚠️ Không tìm thấy region acc trong toadoData (extra.acc). Ảnh ACC không chèn.'); }
      } catch(e){ log('❌ Lỗi chèn ảnh ACC:', e); }
    } else {
      log('Không có file ACC upload (bỏ qua).');
    }

    // draw lichsu image if uploaded
    if(lichsuFileInput.files && lichsuFileInput.files[0]){
      const f = lichsuFileInput.files[0];
      try{
        const dataUrl = await readFileAsDataURL(f);
        const img = await new Promise((res, rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=()=>rej('lichsu img load fail'); i.src=dataUrl; });
        const reg = (toadoData.extra && (toadoData.extra.lichsu || toadoData.extra.lichsuCrop)) || (toadoData.extraLichsu || null);
        if(reg){ drawImageInRegion(img, reg); log('✓ Ảnh Lịch Sử chèn vào region'); }
        else { log('⚠️ Không tìm thấy region lichsu trong toadoData (extra.lichsu). Ảnh Lịch Sử không chèn.'); }
      } catch(e){ log('❌ Lỗi chèn ảnh Lịch Sử:', e); }
    } else {
      log('Không có file Lịch Sử upload (bỏ qua).');
    }

    // draw MS if provided
    const ms = $('msInput').value.trim();
    if(ms && toadoData.ms){
      drawTextAt({ x: toadoData.ms.x, y: toadoData.ms.y }, `MS : ${ms}`, { fill:'#fff', stroke:'#000', size: (toadoData.ms.fontSize || 36) * scaleChoice });
      log('✓ Đã vẽ MS:', ms);
    } else if(ms && !toadoData.ms){
      log('⚠️ MS được nhập nhưng toadoData.ms không tồn tại; bỏ qua.');
    }

    // draw skins into crop
    const cropRegion = (toadoData.crop && (toadoData.crop.original || toadoData.crop)) || toadoData.crop;
    log('Crop region:', cropRegion);
    const placed = await drawSkinsInCrop(cropRegion, parsed.cropSkins || []);
    // populate thumbs
    thumbsEl.innerHTML = '';
    for(const name of parsed.cropSkins || []){
      const d = document.createElement('div'); d.className = 'thumb';
      const url = fileIdMap[name] || null;
      if(url){
        const img = document.createElement('img'); img.src = url; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='contain';
        img.onerror = ()=>{ img.style.opacity = 0.5; img.alt = 'err'; }
        d.appendChild(img);
      } else {
        const txt = document.createElement('div'); txt.style.padding='6px'; txt.style.fontSize='11px'; txt.textContent = name.slice(0,12);
        d.appendChild(txt);
      }
      thumbsEl.appendChild(d);
    }

    countInfo.innerText = `Tướng: ${parsed.tuong} — Skin: ${parsed.skinCount} — Ghép: ${placed}`;
    log('Hoàn tất. Ghép được:', placed);

  } catch(err){
    log('❌ Lỗi xử lý chính:', err && err.message ? err.message : err);
    alert('Có lỗi, xem log để biết chi tiết.');
  }
});

/* Download button */
$('btnDownload').addEventListener('click', ()=>{
  try{
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = 'acc_collage.png';
    a.click();
    log('✅ Xuất ảnh thành công (download).');
  }catch(e){
    log('❌ Lỗi xuất ảnh:', e.message || e);
    alert('Không thể xuất ảnh (có thể do CORS nếu ảnh nền chặn). Xem log.');
  }
});

})(); // end async
</script>
</body>
</html>
